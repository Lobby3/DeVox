# This file was generated. Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type Campaign {
    baalAddress: Bytes!
    donations(first: Int = 100, orderBy: Donation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Donation_filter): [Donation!]!
    id: ID!
    messages(first: Int = 100, orderBy: Message_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Message_filter): [Message!]!
    name: String!
    pricePerUnit: BigInt!
    proposals(first: Int = 100, orderBy: Proposal_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Proposal_filter): [Proposal!]!
    shamanAddress: Bytes!
    target: BigInt!
    tokenAddress: Bytes!
    tokensPerUnit: BigInt!
    total: BigInt!
}

type Donation {
    amount: BigInt!
    campaign: Campaign!
    id: ID!
    loot: BigInt!
    message: Message
    shares: BigInt!
    timestamp: BigInt!
    user: User!
}

type Message {
    campaign: Campaign!
    id: ID!
    text: String!
    user: User!
}

type Proposal {
    actionFailed: Boolean!
    campaign: Campaign!
    cancelled: Boolean!
    details: String!
    expiration: BigInt!
    expired: Boolean!
    id: ID!
    passed: Boolean!
    processed: Boolean!
    selfSponsor: Boolean!
    sponsor: User
    timestamp: BigInt!
    votes(first: Int = 100, orderBy: Vote_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Vote_filter): [Vote!]!
    votingPeriod: BigInt!
    votingStarts: BigInt
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    campaign(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Campaign
    campaigns(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Campaign_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Campaign_filter
    ): [Campaign!]!
    donation(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Donation
    donations(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Donation_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Donation_filter
    ): [Donation!]!
    message(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Message
    messages(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Message_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Message_filter
    ): [Message!]!
    proposal(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Proposal
    proposals(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Proposal_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Proposal_filter
    ): [Proposal!]!
    signature(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Signature
    signatures(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Signature_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Signature_filter
    ): [Signature!]!
    user(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: User_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: User_filter
    ): [User!]!
    vote(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Vote
    votes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Vote_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Vote_filter
    ): [Vote!]!
}

type Signature {
    campaign: Campaign!
    id: ID!
    timestamp: BigInt!
    user: User!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    campaign(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Campaign
    campaigns(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Campaign_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Campaign_filter
    ): [Campaign!]!
    donation(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Donation
    donations(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Donation_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Donation_filter
    ): [Donation!]!
    message(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Message
    messages(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Message_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Message_filter
    ): [Message!]!
    proposal(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Proposal
    proposals(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Proposal_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Proposal_filter
    ): [Proposal!]!
    signature(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Signature
    signatures(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Signature_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Signature_filter
    ): [Signature!]!
    user(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): User
    users(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: User_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: User_filter
    ): [User!]!
    vote(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Vote
    votes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Vote_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Vote_filter
    ): [Vote!]!
}

type User {
    donations(first: Int = 100, orderBy: Donation_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Donation_filter): [Donation!]!
    "User id is an Ethereum address"
    id: Bytes!
    messages(first: Int = 100, orderBy: Message_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Message_filter): [Message!]!
    metadata: Bytes!
    votes(first: Int = 100, orderBy: Vote_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Vote_filter): [Vote!]!
}

type Vote {
    approved: Boolean!
    id: ID!
    proposal: Proposal!
    shares: BigInt!
    user: User!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum Campaign_orderBy {
    baalAddress
    donations
    id
    messages
    name
    pricePerUnit
    proposals
    shamanAddress
    target
    tokenAddress
    tokensPerUnit
    total
}

enum Donation_orderBy {
    amount
    campaign
    campaign__baalAddress
    campaign__id
    campaign__name
    campaign__pricePerUnit
    campaign__shamanAddress
    campaign__target
    campaign__tokenAddress
    campaign__tokensPerUnit
    campaign__total
    id
    loot
    message
    message__id
    message__text
    shares
    timestamp
    user
    user__id
    user__metadata
}

enum Message_orderBy {
    campaign
    campaign__baalAddress
    campaign__id
    campaign__name
    campaign__pricePerUnit
    campaign__shamanAddress
    campaign__target
    campaign__tokenAddress
    campaign__tokensPerUnit
    campaign__total
    id
    text
    user
    user__id
    user__metadata
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum Proposal_orderBy {
    actionFailed
    campaign
    campaign__baalAddress
    campaign__id
    campaign__name
    campaign__pricePerUnit
    campaign__shamanAddress
    campaign__target
    campaign__tokenAddress
    campaign__tokensPerUnit
    campaign__total
    cancelled
    details
    expiration
    expired
    id
    passed
    processed
    selfSponsor
    sponsor
    sponsor__id
    sponsor__metadata
    timestamp
    votes
    votingPeriod
    votingStarts
}

enum Signature_orderBy {
    campaign
    campaign__baalAddress
    campaign__id
    campaign__name
    campaign__pricePerUnit
    campaign__shamanAddress
    campaign__target
    campaign__tokenAddress
    campaign__tokensPerUnit
    campaign__total
    id
    timestamp
    user
    user__id
    user__metadata
}

enum User_orderBy {
    donations
    id
    messages
    metadata
    votes
}

enum Vote_orderBy {
    approved
    id
    proposal
    proposal__actionFailed
    proposal__cancelled
    proposal__details
    proposal__expiration
    proposal__expired
    proposal__id
    proposal__passed
    proposal__processed
    proposal__selfSponsor
    proposal__timestamp
    proposal__votingPeriod
    proposal__votingStarts
    shares
    user
    user__id
    user__metadata
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

"""

8 bytes signed integer
"""
scalar Int8

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input Campaign_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Campaign_filter]
    baalAddress: Bytes
    baalAddress_contains: Bytes
    baalAddress_gt: Bytes
    baalAddress_gte: Bytes
    baalAddress_in: [Bytes!]
    baalAddress_lt: Bytes
    baalAddress_lte: Bytes
    baalAddress_not: Bytes
    baalAddress_not_contains: Bytes
    baalAddress_not_in: [Bytes!]
    donations_: Donation_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    messages_: Message_filter
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [Campaign_filter]
    pricePerUnit: BigInt
    pricePerUnit_gt: BigInt
    pricePerUnit_gte: BigInt
    pricePerUnit_in: [BigInt!]
    pricePerUnit_lt: BigInt
    pricePerUnit_lte: BigInt
    pricePerUnit_not: BigInt
    pricePerUnit_not_in: [BigInt!]
    proposals_: Proposal_filter
    shamanAddress: Bytes
    shamanAddress_contains: Bytes
    shamanAddress_gt: Bytes
    shamanAddress_gte: Bytes
    shamanAddress_in: [Bytes!]
    shamanAddress_lt: Bytes
    shamanAddress_lte: Bytes
    shamanAddress_not: Bytes
    shamanAddress_not_contains: Bytes
    shamanAddress_not_in: [Bytes!]
    target: BigInt
    target_gt: BigInt
    target_gte: BigInt
    target_in: [BigInt!]
    target_lt: BigInt
    target_lte: BigInt
    target_not: BigInt
    target_not_in: [BigInt!]
    tokenAddress: Bytes
    tokenAddress_contains: Bytes
    tokenAddress_gt: Bytes
    tokenAddress_gte: Bytes
    tokenAddress_in: [Bytes!]
    tokenAddress_lt: Bytes
    tokenAddress_lte: Bytes
    tokenAddress_not: Bytes
    tokenAddress_not_contains: Bytes
    tokenAddress_not_in: [Bytes!]
    tokensPerUnit: BigInt
    tokensPerUnit_gt: BigInt
    tokensPerUnit_gte: BigInt
    tokensPerUnit_in: [BigInt!]
    tokensPerUnit_lt: BigInt
    tokensPerUnit_lte: BigInt
    tokensPerUnit_not: BigInt
    tokensPerUnit_not_in: [BigInt!]
    total: BigInt
    total_gt: BigInt
    total_gte: BigInt
    total_in: [BigInt!]
    total_lt: BigInt
    total_lte: BigInt
    total_not: BigInt
    total_not_in: [BigInt!]
}

input Donation_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    and: [Donation_filter]
    campaign: String
    campaign_: Campaign_filter
    campaign_contains: String
    campaign_contains_nocase: String
    campaign_ends_with: String
    campaign_ends_with_nocase: String
    campaign_gt: String
    campaign_gte: String
    campaign_in: [String!]
    campaign_lt: String
    campaign_lte: String
    campaign_not: String
    campaign_not_contains: String
    campaign_not_contains_nocase: String
    campaign_not_ends_with: String
    campaign_not_ends_with_nocase: String
    campaign_not_in: [String!]
    campaign_not_starts_with: String
    campaign_not_starts_with_nocase: String
    campaign_starts_with: String
    campaign_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    loot: BigInt
    loot_gt: BigInt
    loot_gte: BigInt
    loot_in: [BigInt!]
    loot_lt: BigInt
    loot_lte: BigInt
    loot_not: BigInt
    loot_not_in: [BigInt!]
    message: String
    message_: Message_filter
    message_contains: String
    message_contains_nocase: String
    message_ends_with: String
    message_ends_with_nocase: String
    message_gt: String
    message_gte: String
    message_in: [String!]
    message_lt: String
    message_lte: String
    message_not: String
    message_not_contains: String
    message_not_contains_nocase: String
    message_not_ends_with: String
    message_not_ends_with_nocase: String
    message_not_in: [String!]
    message_not_starts_with: String
    message_not_starts_with_nocase: String
    message_starts_with: String
    message_starts_with_nocase: String
    or: [Donation_filter]
    shares: BigInt
    shares_gt: BigInt
    shares_gte: BigInt
    shares_in: [BigInt!]
    shares_lt: BigInt
    shares_lte: BigInt
    shares_not: BigInt
    shares_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

input Message_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Message_filter]
    campaign: String
    campaign_: Campaign_filter
    campaign_contains: String
    campaign_contains_nocase: String
    campaign_ends_with: String
    campaign_ends_with_nocase: String
    campaign_gt: String
    campaign_gte: String
    campaign_in: [String!]
    campaign_lt: String
    campaign_lte: String
    campaign_not: String
    campaign_not_contains: String
    campaign_not_contains_nocase: String
    campaign_not_ends_with: String
    campaign_not_ends_with_nocase: String
    campaign_not_in: [String!]
    campaign_not_starts_with: String
    campaign_not_starts_with_nocase: String
    campaign_starts_with: String
    campaign_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [Message_filter]
    text: String
    text_contains: String
    text_contains_nocase: String
    text_ends_with: String
    text_ends_with_nocase: String
    text_gt: String
    text_gte: String
    text_in: [String!]
    text_lt: String
    text_lte: String
    text_not: String
    text_not_contains: String
    text_not_contains_nocase: String
    text_not_ends_with: String
    text_not_ends_with_nocase: String
    text_not_in: [String!]
    text_not_starts_with: String
    text_not_starts_with_nocase: String
    text_starts_with: String
    text_starts_with_nocase: String
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

input Proposal_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    actionFailed: Boolean
    actionFailed_in: [Boolean!]
    actionFailed_not: Boolean
    actionFailed_not_in: [Boolean!]
    and: [Proposal_filter]
    campaign: String
    campaign_: Campaign_filter
    campaign_contains: String
    campaign_contains_nocase: String
    campaign_ends_with: String
    campaign_ends_with_nocase: String
    campaign_gt: String
    campaign_gte: String
    campaign_in: [String!]
    campaign_lt: String
    campaign_lte: String
    campaign_not: String
    campaign_not_contains: String
    campaign_not_contains_nocase: String
    campaign_not_ends_with: String
    campaign_not_ends_with_nocase: String
    campaign_not_in: [String!]
    campaign_not_starts_with: String
    campaign_not_starts_with_nocase: String
    campaign_starts_with: String
    campaign_starts_with_nocase: String
    cancelled: Boolean
    cancelled_in: [Boolean!]
    cancelled_not: Boolean
    cancelled_not_in: [Boolean!]
    details: String
    details_contains: String
    details_contains_nocase: String
    details_ends_with: String
    details_ends_with_nocase: String
    details_gt: String
    details_gte: String
    details_in: [String!]
    details_lt: String
    details_lte: String
    details_not: String
    details_not_contains: String
    details_not_contains_nocase: String
    details_not_ends_with: String
    details_not_ends_with_nocase: String
    details_not_in: [String!]
    details_not_starts_with: String
    details_not_starts_with_nocase: String
    details_starts_with: String
    details_starts_with_nocase: String
    expiration: BigInt
    expiration_gt: BigInt
    expiration_gte: BigInt
    expiration_in: [BigInt!]
    expiration_lt: BigInt
    expiration_lte: BigInt
    expiration_not: BigInt
    expiration_not_in: [BigInt!]
    expired: Boolean
    expired_in: [Boolean!]
    expired_not: Boolean
    expired_not_in: [Boolean!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [Proposal_filter]
    passed: Boolean
    passed_in: [Boolean!]
    passed_not: Boolean
    passed_not_in: [Boolean!]
    processed: Boolean
    processed_in: [Boolean!]
    processed_not: Boolean
    processed_not_in: [Boolean!]
    selfSponsor: Boolean
    selfSponsor_in: [Boolean!]
    selfSponsor_not: Boolean
    selfSponsor_not_in: [Boolean!]
    sponsor: String
    sponsor_: User_filter
    sponsor_contains: String
    sponsor_contains_nocase: String
    sponsor_ends_with: String
    sponsor_ends_with_nocase: String
    sponsor_gt: String
    sponsor_gte: String
    sponsor_in: [String!]
    sponsor_lt: String
    sponsor_lte: String
    sponsor_not: String
    sponsor_not_contains: String
    sponsor_not_contains_nocase: String
    sponsor_not_ends_with: String
    sponsor_not_ends_with_nocase: String
    sponsor_not_in: [String!]
    sponsor_not_starts_with: String
    sponsor_not_starts_with_nocase: String
    sponsor_starts_with: String
    sponsor_starts_with_nocase: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    votes_: Vote_filter
    votingPeriod: BigInt
    votingPeriod_gt: BigInt
    votingPeriod_gte: BigInt
    votingPeriod_in: [BigInt!]
    votingPeriod_lt: BigInt
    votingPeriod_lte: BigInt
    votingPeriod_not: BigInt
    votingPeriod_not_in: [BigInt!]
    votingStarts: BigInt
    votingStarts_gt: BigInt
    votingStarts_gte: BigInt
    votingStarts_in: [BigInt!]
    votingStarts_lt: BigInt
    votingStarts_lte: BigInt
    votingStarts_not: BigInt
    votingStarts_not_in: [BigInt!]
}

input Signature_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Signature_filter]
    campaign: String
    campaign_: Campaign_filter
    campaign_contains: String
    campaign_contains_nocase: String
    campaign_ends_with: String
    campaign_ends_with_nocase: String
    campaign_gt: String
    campaign_gte: String
    campaign_in: [String!]
    campaign_lt: String
    campaign_lte: String
    campaign_not: String
    campaign_not_contains: String
    campaign_not_contains_nocase: String
    campaign_not_ends_with: String
    campaign_not_ends_with_nocase: String
    campaign_not_in: [String!]
    campaign_not_starts_with: String
    campaign_not_starts_with_nocase: String
    campaign_starts_with: String
    campaign_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [Signature_filter]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}

input User_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [User_filter]
    donations_: Donation_filter
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    messages_: Message_filter
    metadata: Bytes
    metadata_contains: Bytes
    metadata_gt: Bytes
    metadata_gte: Bytes
    metadata_in: [Bytes!]
    metadata_lt: Bytes
    metadata_lte: Bytes
    metadata_not: Bytes
    metadata_not_contains: Bytes
    metadata_not_in: [Bytes!]
    or: [User_filter]
    votes_: Vote_filter
}

input Vote_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Vote_filter]
    approved: Boolean
    approved_in: [Boolean!]
    approved_not: Boolean
    approved_not_in: [Boolean!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [Vote_filter]
    proposal: String
    proposal_: Proposal_filter
    proposal_contains: String
    proposal_contains_nocase: String
    proposal_ends_with: String
    proposal_ends_with_nocase: String
    proposal_gt: String
    proposal_gte: String
    proposal_in: [String!]
    proposal_lt: String
    proposal_lte: String
    proposal_not: String
    proposal_not_contains: String
    proposal_not_contains_nocase: String
    proposal_not_ends_with: String
    proposal_not_ends_with_nocase: String
    proposal_not_in: [String!]
    proposal_not_starts_with: String
    proposal_not_starts_with_nocase: String
    proposal_starts_with: String
    proposal_starts_with_nocase: String
    shares: BigInt
    shares_gt: BigInt
    shares_gte: BigInt
    shares_in: [BigInt!]
    shares_lt: BigInt
    shares_lte: BigInt
    shares_not: BigInt
    shares_not_in: [BigInt!]
    user: String
    user_: User_filter
    user_contains: String
    user_contains_nocase: String
    user_ends_with: String
    user_ends_with_nocase: String
    user_gt: String
    user_gte: String
    user_in: [String!]
    user_lt: String
    user_lte: String
    user_not: String
    user_not_contains: String
    user_not_contains_nocase: String
    user_not_ends_with: String
    user_not_ends_with_nocase: String
    user_not_in: [String!]
    user_not_starts_with: String
    user_not_starts_with_nocase: String
    user_starts_with: String
    user_starts_with_nocase: String
}
